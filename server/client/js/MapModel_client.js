//LICENSED CODE BY SAMUEL MAGNAN FOR RAININGCHAIN.COM, LICENSE INFORMATION AT GITHUB.COM/RAININGCHAIN/RAININGCHAIN
"use strict";
(function(){ //}
var Img = require4('Img'), Dialog = require4('Dialog');
var MapModel = exports.MapModel = {};

var IMG_W = 640;
var IMG_H = 360;

var SIZEFACT = 2;		//enlarge the map image by this factor
	
MapModel.create = function(quest,name,sizeX,sizeY,grid,width,height){
	var tmp = {
		id:quest + '-' + name,
		graphicPath:'',
		quest:quest,
		subId:name,
		name:'',	//init in MapModel.initName using server signInPack
		img:MapModel.Img(),
		grid:grid,
		sizeX:sizeX,	//in image count
		sizeY:sizeY,
		width:width,	//in pixel
		height:height,
		imageLoaded:false,		
	};
	DB[tmp.id] = tmp;
}	
var DB = MapModel.DB = {};
	

MapModel.Img = function(){
	return {
		a:[],
		b:[],
		m:null,
	};
}	
MapModel.getFullPath = function(graphicPath,layer,x,y){
	if(layer === 'm') return graphicPath + 'M.png';
	return graphicPath + layer.$capitalize() + '_(' + x + ',' + y + ')' + '.png';
}

MapModel.initImage = function(map){
	if(map.imageLoaded) return ERROR(3,'already loaded images');
	//layer
	var param = {
		value:0,
		min:0,
		max:0,
	}
	var loadcb = function(){
		param.value++;
	}
	
	for(var i = 0 ; i <= map.sizeX; i++){
		map.img.a[i] = [];
		map.img.b[i] = [];
		for(var j = 0 ; j <= map.sizeY; j++){
			param.max += 2;
			map.img.a[i].push(Img.load(MapModel.getFullPath(map.graphicPath,'a',i,j),loadcb));
			map.img.b[i].push(Img.load(MapModel.getFullPath(map.graphicPath,'b',i,j),loadcb));
		}
	}
	//minimap
	param.max++;
	map.img.m = Img.load(MapModel.getFullPath(map.graphicPath,'m'),loadcb); // 8 times smaller than regular map generated by tiled
	map.imageLoaded = true;
	
	Dialog.open('processBar',param,true);
}

MapModel.useSignInPack = function(nameList){
	for(var i in nameList){
		if(i === nameList[i].graphic){	//base map
			var sizeX = Math.ceil(nameList[i].width/640/2)-1;	// /2 cuz x2 smaller than real. -1 cuz 0 means 1 map
			var sizeY = Math.ceil(nameList[i].height/360/2)-1;	// /2 cuz x2 smaller than real
			
			var widthSq = nameList[i].width/32;	//BADD
			var heightSq = nameList[i].height/32;
			var grid = nameList[i].gridPlayer ? MapModel.Grid.uncompress(nameList[i].gridPlayer,widthSq,heightSq) : 0;
			
			MapModel.create(i.split('-')[0],i.split('-')[1],sizeX,sizeY,grid,nameList[i].width,nameList[i].height);
		}
	}
	
	for(var i in nameList){
		try {
			if(!DB[i]) 
				DB[i] = Tk.deepClone(DB[nameList[i].graphic]);	//case map using graphic of other, that map isnt on client side init
			DB[i].name = nameList[i].name;
			//gridPlayer?
			DB[i].graphicPath = MapModel.generateGraphicPath(nameList[i].graphic);		
		}catch(err){
			ERROR(2,i,'map not found');
		}
	}
}

MapModel.generateGraphicPath = function(graphic){
	var quest = graphic.split('-')[0];
	var name = graphic.split('-')[1];
	return "quest/" + quest + "/map/" + name + "/" + name;
}	

MapModel.getCurrent = function(){
	return DB[player.map];
}

MapModel.get = function(id){
	return DB[id];
}
MapModel.getFast = function(id){
	return MapModel.get(id);
}
MapModel.getZoneDrawOnScreen = function(){	//return zone that isnt black
	var map = MapModel.get(player.map);

	var left = Math.max(0,Tk.absToRel.x(0));
	var top = Math.max(0,Tk.absToRel.y(0));
	var right = Math.min(CST.WIDTH,Tk.absToRel.x(map.width));
	var bottom = Math.min(CST.HEIGHT,Tk.absToRel.y(map.height));
	return {x:left,y:top,width:right-left, height:bottom-top};
}

MapModel.draw = function (ctx,layer){
	var map = MapModel.getCurrent();
	
	var offsetX = Tk.absToRel.x(0);
	var offsetY = Tk.absToRel.y(0);
	
	for(var i = 0; i < map.img[layer].length; i++){
		for(var j = 0; j < map.img[layer][i].length; j++){
			var mapXY = map.img[layer][i][j];
			
			var posX = offsetX + IMG_W*SIZEFACT*i;	//absolute position top left of image
			var posY = offsetY + IMG_H*SIZEFACT*j;
			
			//problem if map not whole
			var iwResized = IMG_W.mm(0,mapXY.width);
			var ihResized = IMG_H.mm(0,mapXY.height);
			
			if(posX < -iwResized*SIZEFACT || posY < -ihResized*SIZEFACT
				|| posX > CST.WIDTH || posY > CST.HEIGHT){
				continue;	//aka not visible
			}
			ctx.drawImage(mapXY, 0,0,iwResized,ihResized,
				posX,posY,
				iwResized*SIZEFACT,
				ihResized*SIZEFACT
			);
			/*
			//TRIPPY
			var vx = posX < 0 ? -posX : 0;
			var vy = posY < 0 ? -posY : 0;
				
			ctx.drawImage(mapXY, vx/2,vy/2,iwResized-vy/2,ihResized-vy/2,
				posX+vx,posY+vy,
				iwResized*SIZEFACT+vx,ihResized*SIZEFACT+vy
			);
			*/
		}
	}
}


MapModel.Grid = function(player){
	return {
		player:player
	}
}
MapModel.Grid.uncompress = function(compressed,width,height){ //compress in MapModel
	var oneD = Tk.baseConverter.toBinary(compressed);
	oneD = oneD.$replaceAll(' ','');
	var twoD = [];
	for(var i = 0 ; i < height; i++){
		twoD.push(oneD.slice(i*width,i*width+width));
	}
	return MapModel.Grid(twoD);
}




})();














